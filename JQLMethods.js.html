<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JQLMethods.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-JQL.html">JQL</a><ul class='methods'><li data-type='method'><a href="module-JQL.html#~ExtendedNodeList">ExtendedNodeList</a></li><li data-type='method'><a href="module-JQL.html#~JQL/allowUnknownHtmlTags">JQL/allowUnknownHtmlTags</a></li><li data-type='method'><a href="module-JQL.html#~JQL/debugLog">JQL/debugLog</a></li><li data-type='method'><a href="module-JQL.html#~JQL/delegate">JQL/delegate</a></li><li data-type='method'><a href="module-JQL.html#~JQL/insertPositions">JQL/insertPositions</a></li><li data-type='method'><a href="module-JQL.html#~JQL/log">JQL/log</a></li><li data-type='method'><a href="module-JQL.html#~JQL/logElementCreationErrors">JQL/logElementCreationErrors</a></li><li data-type='method'><a href="module-JQL.html#~JQL/node">JQL/node</a></li><li data-type='method'><a href="module-JQL.html#~JQL/nodes">JQL/nodes</a></li><li data-type='method'><a href="module-JQL.html#~JQL/popup">JQL/popup</a></li><li data-type='method'><a href="module-JQL.html#~JQL/setStyle">JQL/setStyle</a></li><li data-type='method'><a href="module-JQL.html#~JQL/setStyling4Log">JQL/setStyling4Log</a></li><li data-type='method'><a href="module-JQL.html#~JQL/setSystemLogActiveState">JQL/setSystemLogActiveState</a></li><li data-type='method'><a href="module-JQL.html#~JQL/setTagPermission">JQL/setTagPermission</a></li><li data-type='method'><a href="module-JQL.html#~JQL/text">JQL/text</a></li><li data-type='method'><a href="module-JQL.html#~JQL/time">JQL/time</a></li><li data-type='method'><a href="module-JQL.html#~JQL/virtual">JQL/virtual</a></li></ul></li><li><a href="module-JQL_JQLLog.html">JQL/JQLLog</a><ul class='methods'><li data-type='method'><a href="module-JQL_JQLLog.html#.reversed">reversed</a></li><li data-type='method'><a href="module-JQL_JQLLog.html#.toConsole">toConsole</a></li><li data-type='method'><a href="module-JQL_JQLLog.html#~Log">Log</a></li><li data-type='method'><a href="module-JQL_JQLLog.html#~setStyling4Log">setStyling4Log</a></li></ul></li><li><a href="module-JQL_JQLMethods.html">JQL/JQLMethods</a><ul class='methods'><li data-type='method'><a href="module-JQL_JQLMethods.html#.addClass">addClass</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.append">append</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.appendTo">appendTo</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.assignAttrValues">assignAttrValues</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.attr">attr</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.clear">clear</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.computedStyle">computedStyle</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.css">css</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.delegate">delegate</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.dimensions">dimensions</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.duplicate">duplicate</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.each">each</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.empty">empty</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.find">find</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.find$">find$</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.first">first</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.first$">first$</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.getData">getData</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.hasClass">hasClass</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.hide">hide</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.html">html</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.htmlFor">htmlFor</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.is">is</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.on">on</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.ON">ON</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.outerHtml">outerHtml</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.parent">parent</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.prepend">prepend</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.prependTo">prependTo</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.prop">prop</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.remove">remove</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.removeAttr">removeAttr</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.removeClass">removeClass</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.replace">replace</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.replaceClass">replaceClass</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.replaceMe">replaceMe</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.setData">setData</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.show">show</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.single">single</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.style">style</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.text">text</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.toDOM">toDOM</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.toggleAttr">toggleAttr</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.toggleClass">toggleClass</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.toNodeList">toNodeList</a></li><li data-type='method'><a href="module-JQL_JQLMethods.html#.val">val</a></li></ul></li><li><a href="module-JQL_Popup.html">JQL/Popup</a><ul class='methods'><li data-type='method'><a href="module-JQL_Popup.html#.popupFactory">popupFactory</a></li></ul></li><li><a href="module-JQL_XHelpers_Attributes.html">JQL/XHelpers/Attributes</a></li><li><a href="module-JQL_XHelpers_DOM.html">JQL/XHelpers/DOM</a><ul class='methods'><li data-type='method'><a href="module-JQL_XHelpers_DOM.html#~createElementFromHtmlString">createElementFromHtmlString</a></li><li data-type='method'><a href="module-JQL_XHelpers_DOM.html#~element2DOM">element2DOM</a></li></ul></li><li><a href="module-JQL_XHelpers_ExtensionHelpers.html">JQL/XHelpers/ExtensionHelpers</a><ul class='methods'><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~hex2Full">hex2Full</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~hex2RGBA">hex2RGBA</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~initializePrototype">initializePrototype</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~isObjectAndNotArray">isObjectAndNotArray</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~isVisible">isVisible</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~loop">loop</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~time">time</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~toDashedNotation">toDashedNotation</a></li><li data-type='method'><a href="module-JQL_XHelpers_ExtensionHelpers.html#~truncateHtmlStr">truncateHtmlStr</a></li></ul></li><li><a href="module-JQL_XHelpers_HandlerFactory.html">JQL/XHelpers/HandlerFactory</a><ul class='methods'><li data-type='method'><a href="module-JQL_XHelpers_HandlerFactory.html#~addListenerIfNotExisting">addListenerIfNotExisting</a></li><li data-type='method'><a href="module-JQL_XHelpers_HandlerFactory.html#~createHandlerForHID">createHandlerForHID</a></li><li data-type='method'><a href="module-JQL_XHelpers_HandlerFactory.html#~metaHandler">metaHandler</a></li></ul></li><li><a href="module-JQL_XHelpers_HtmlCleanup.html">JQL/XHelpers/HtmlCleanup</a><ul class='methods'><li data-type='method'><a href="module-JQL_XHelpers_HtmlCleanup.html#~logElementCreationErrors">logElementCreationErrors</a></li><li data-type='method'><a href="module-JQL_XHelpers_HtmlCleanup.html#~setTagPermission">setTagPermission</a></li></ul></li><li><a href="module-JQL_XHelpers_HtmlTags.html">JQL/XHelpers/HtmlTags</a><ul class='methods'><li data-type='method'><a href="module-JQL_XHelpers_HtmlTags.html#.isAllowed">isAllowed</a></li><li data-type='method'><a href="module-JQL_XHelpers_HtmlTags.html#~setTagPermission">setTagPermission</a></li></ul></li><li><a href="module-JQL_XHelpers_Styling.html">JQL/XHelpers/Styling</a><ul class='methods'><li data-type='method'><a href="module-JQL_XHelpers_Styling.html#~changeCssStyleRule">changeCssStyleRule</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">JQLMethods.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// noinspection JSUnresolvedVariable,JSUnusedGlobalSymbols, GrazieInspection
// noinspection JSUnusedGlobalSymbols

import _$ from "./JQueryLike.js";
import {setStyle} from "./Styling.js";
import {createElementFromHtmlString, insertPositions} from "./DOM.js";
import {
  hex2RGBA,
  loop,
  addHandlerId,
  isVisible,
  isNode,
  isObjectAndNotArray,
  randomString,
  inject2DOMTree } from "./JQLExtensionHelpers.js";
import handlerFactory from "./HandlerFactory.js";

/**
 * All extension methods for &lt;code>ExtendedNodeList&lt;/code>.
 * These methods end up being part of the JQL prototype
 * ([See JQLExtensionHelpers/initializePrototype]{@link module:JQL/XHelpers/ExtensionHelpers~initializePrototype})
 * &lt;br>&lt;b>Note&lt;/b>: Most methods are &lt;i>chainable&lt;/i> (see example).
 * @module JQL/JQLMethods
 * @example
 * import $ from "JQueryLike.js";
 * // chainability means:
 * $(`&lt;div id="helloworld">`)
 *  .text(`Example: hello ... world`)
 *  .append($(`&lt;span> OK&lt;/span>`))
 *  .css({
 *    marginTop: `0.5rem`,
 *    border: `3px solid green`,
 *    padding: `5px`,
 *    fontSize: `1.2em`,
 *    display: `inline-block`, })
 *  .find$(`span`)
 *  .css({className: `okRed`, color: `red`});
 *  // result (class names are partly random):
 *  // &lt;div id="helloworld" class="JQLCreated_YZ5XnwbCEGxH">Example: hello ... world&lt;span class="okRed"> OK&lt;/span>&lt;/div>
 */
const empty = el => el &amp;&amp; (el.textContent = "");
/**
 * Set data-attribute for each element of the element collection of the ExtendedNodeList.
 * The attributes must be key-value pairs.
 * @memberof module:JQL/JQLMethods
 * @param keyValuePairs {Object.&lt;string, string>} Object e.g. &amp;#123;isSet: 'true'&amp;#125;
 * &lt;br>&lt;b>Note&lt;/b> do &lt;i>not&lt;/i> use dashed keys but camelcase if you
 * need to split up the dataset. &lt;b>wrong&lt;/b>: &lt;code>no-code&lt;/code>, &lt;b>right&lt;/b>: &lt;code>noCode&lt;/code>.
 * The latter will be &lt;i>rendered&lt;/i> as &lt;code>`data-no-code`&lt;/code> in HTML, but not in js-code.
 */
const setData = (el, keyValuePairs) => {
  el &amp;&amp; isObjectAndNotArray(keyValuePairs) &amp;&amp;
  Object.entries(keyValuePairs).forEach(([key, value]) => el.dataset[key] = value);
};

const inputElems = [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement];

/**
 * Style each element of the element collection of the ExtendedNodeList
 * instance &lt;i>within a custom style sheet&lt;/i>, using an intermediate class
 * or given className
 * &lt;br>&lt;b>Note&lt;/b>: the intermediate &lt;code>className&lt;/code> starts with`jQLCreated_`.
 * There will be one intermediate class name per element. Subsequent .css calls will
 * change the rules for that class name.
 * &lt;br>Preferably use key-value pairs, even when assigning a single property.
 * @example
 * // presume $ is the alias for ExtendedNodeList
 * $(`&lt;p>`).css({marginLeft: `12px`, color: `green`, borderLeft: `2px solid red`})
 * // the document will now contain &lt;p class="JQLCreated_[a random string]">&lt;/p>
 * // use your own class name
 * $(`&lt;p>`).css({className: `leftRedBorder`, marginLeft: `12px`, color: `green`, borderLeft: `2px solid red`});
 * // the document will now contain &lt;p class="leftRedBorder">&lt;/p>
 * @memberof module:JQL/JQLMethods
 * @param keyOrKvPairs {Object.&lt;string, string>|string} Object or string e.g. &lt;code>&amp;#123;marginRight: '12px'&amp;#125;&lt;/code>
 * or &lt;code>'margin-right'&lt;/code>
 * &lt;br>key or string may be: `paddingRight` or `"padding-right"`
 * &lt;br>&lt;b>Note&lt;/b>: if you want to use your own class name (so not a random name),
 * include a &lt;code>className&lt;/code> property in the Object. See example.
 * @param value {string|undefined} if value is not &lt;code>undefined&lt;/code>, keyOrKvPairs should be a string too
 * &lt;br>If the value should be empty (reset: e.g. &lt;code>padding: ""&lt;/code>), use a dash "-"
 */
const css = (el, keyOrKvPairs, value) => {
  if (value &amp;&amp; keyOrKvPairs.constructor === String) {
    keyOrKvPairs = {[keyOrKvPairs]: value === "-" ? "" : value};
  }

  let nwClass = undefined;

  if (keyOrKvPairs.className) {
    nwClass = keyOrKvPairs.className;
    delete keyOrKvPairs.className;
  }

  const classExists = ([...el.classList].find(c => c.startsWith(`JQLCreated`) || nwClass &amp;&amp; c === nwClass));
  nwClass = classExists || nwClass || `JQLCreated_${randomString.randomHtmlElementId(12)}`;
  setStyle(`.${nwClass}`, keyOrKvPairs);
  el.classList.add(nwClass);
};
/**
 * Set attribute or property values for each element of the element collection of the ExtendedNodeList.
 * of the ExtendedNodeList instance
 * @memberof module:JQL/JQLMethods
 * @param keyValuePairs {Object} Object e.g. &amp;#123;title: 'I am Groot'&amp;#125;
 */
const assignAttrValues = (el, keyValuePairs) => {
  el &amp;&amp; Object.entries(keyValuePairs).forEach(([key, value]) => {
    if (key.startsWith(`data`)) {
      setData(el, {[key]: value});
    }

    if (key.toLowerCase() === "class") {
      value.split(/\s+/).forEach(v => el.classList.add(`${v}`))
    }

    if (value.constructor === String) {
      el[key] = value;
    }
  });
};
const allMethods = {
  straigthLoops: {
    /**
     * Toggle className (on/off) for each element of the element collection of the ExtendedNodeList.
     * @memberof module:JQL/JQLMethods
     * @param className {string} the class name to toggle (eg 'hidden')
     */
    toggleClass: (el, className) => el.classList.toggle(className),
    /**
     * Toggle individual style properties for each element of the element collection of the ExtendedNodeList.
     * Properties must be key-value pairs
     * Note: this may fail, because browsers may reformat style values in their own way.
     * For colors, hex values are converted (see the [color helper]{@link module:JQL/XHelpers/ExtensionHelpers~hex2RGBA}).
     * @memberof module:JQL/JQLMethods#straightLoops
     * @param keyValuePairs {Object} e.g. &amp;#123;marginRight: '12px'&amp;#125;
     */
    toggleStyleFragments: (el, keyValuePairs) =>
      el &amp;&amp; Object.entries(keyValuePairs).forEach(([key, value]) => {
        if (value instanceof Function) {
          value = value(el);
        }

        if (/color/i.test(key)) {
          value = value.startsWith(`#`)
            ? hex2RGBA(value)
            : value.replace(/(,|,\s{2,})(\w)/g, (...args) => `, ${args[2]}`);
        }

        el.style[key] = `${el.style[key]}` === `${value}` ? "" : value;
      }),
    /**
     * Remove some attribute from each element of the element collection of the ExtendedNodeList.
     * @memberof module:JQL/JQLMethods
     * @param name {string} the attribute name
     */
    removeAttr: (el, name) => el &amp;&amp; el.removeAttribute(name),
    /**
     * Toggle attribute [name] with [value] for each element of the element collection of the ExtendedNodeList.
     * @memberof module:JQL/JQLMethods
     * @param name {string} attribute name (e.g. 'title')
     * @param value {string} attribute value to set
     */
    toggleAttr: (el, name, value) =>
      el &amp;&amp; el.hasAttribute(name)
        ? el.removeAttribute(name)
        : el.setAttribute(name, value),
    /**
     * Remove contents for all elements of the collection
     * @function empty
     * @memberof module:JQL/JQLMethods
     */
    empty,
    /**
     * Alias for empty. Remove contents for all elements of the collection
     * @function clear
     * @memberof module:JQL/JQLMethods
     */
    clear: empty,
    /**
     * Swap [classname] with [...nwClassnames] for each element of the element collection of the ExtendedNodeList.
     * Enables replacing a class name with one or more class name(s)
     * @memberof module:JQL/JQLMethods
     * @param className {string} the className to replace
     * @param nwClassNames {...string} the class name(s) to replace [className] with
     */
    replaceClass: (el, className, ...nwClassNames) => {
      el.classList.remove(className);
      nwClassNames.forEach(name => el.classList.add(name))
    },
    /**
     * Remove [classNames] from for each element of the element collection of the ExtendedNodeList.
     * Class names can be one or more strings.
     * @memberof module:JQL/JQLMethods
     * @param classNames {...string} one or more class names
     */
    removeClass: (el, ...classNames) =>
      classNames.forEach(cn => el.classList.remove(cn)),
    /**
     * Add [classNames] to each element of the element collection of the ExtendedNodeList.
     * Class names can be one or more strings
     * @memberof module:JQL/JQLMethods
     * @param classNames {...string} one or more class names
     */
    addClass: (el, ...classNames) => el &amp;&amp; classNames.forEach(cn => el.classList.add(cn)),
    /**
     * Show each element of the element collection of the ExtendedNodeList.
     * @memberof module:JQL/JQLMethods
     */
    show: el => el.style.display = ``,
    /**
     * Hide each element of the element collection of the ExtendedNodeList.
     * @memberof module:JQL/JQLMethods
     */
    hide: el => el.style.display = `none`,
    setData,
    assignAttrValues,
    /**
     * Get or set attributes for each element of the element collection of the ExtendedNodeList
     * of the ExtendedNodeList instance
     * attributes must be key-value pairs
     * style and data-attributes must also be key-value pairs
     * @memberof module:JQL/JQLMethods
     * @param keyOrObj {string|Object} Object e.g. &amp;#123;color: '#c0c0c0'&amp;#125;
     * @param value {string} some value
     * @returns {*|string}
     */
    attr(el, keyOrObj, value) {
      if (!el) {
        return true;
      }

      if (value !== undefined) {
        keyOrObj = {[keyOrObj]: value};
      }

      if (!value &amp;&amp; keyOrObj.constructor === String) {
        return el.getAttribute(keyOrObj);
      }

      Object.entries(keyOrObj).forEach(([key, value]) => {
        const keyCompare = key.toLowerCase().trim();

        if (keyCompare === `style`) {
          return css(el, value, undefined);
        }

        if (keyCompare === `data`) {
          return setData(el, value);
        }

        if (value instanceof Object) {
          return assignAttrValues(el, value);
        }

        return el.setAttribute(key, value);
      });
    },
    /**
     * Style each element of the element collection of the ExtendedNodeList &lt;i>inline&lt;/i>,
     * so &lt;code>&amp;lt;div style="[the style from parameters]">&lt;/code>.
     * Preferably use key-value pairs
     * @memberof module:JQL/JQLMethods
     * @param keyOrKvPairs {Object|string} Object e.g. &lt;code>&amp;#123;marginRight: '12px'&amp;#125&lt;/code>,
     * or string e.g. &lt;code>"marginRight"&lt;/code>
     * &lt;br>key may be: `paddingRight` or `"padding-right"`
     * @param value {string|undefined} if value is not &lt;code>undefined&lt;/code>,
     * keyOrKvPairs should be a string too
     * &lt;br>If the value should be empty (reset: e.g. &lt;code>padding: ""&lt;/code>), use a dash "-"
     */
    style: (el, keyOrKvPairs, value) => {
      if (value &amp;&amp; keyOrKvPairs.constructor === String) {
        keyOrKvPairs = {[keyOrKvPairs]: value || "none"};
      }

      if (!Array.isArray((keyOrKvPairs)) &amp;&amp; keyOrKvPairs.constructor === Object) {
        Object.entries(keyOrKvPairs).forEach(([key, value]) => el.style[key] = value);
      }
    },
    css,
  },
  instanceExtensions: {
    /**
     * Get textContent of the first element in the
     * the collection of [extCollection] or set the textContent
     * for each element of the collection. .
     * overwrites current textContent of the first element,
     * or appends the text to it.
     * &lt;br>&lt;b>Note&lt;/b>: uses textContent, so no html here
     * @memberof module:JQL/JQLMethods
     * @param textValue {string|undefined} the text to inject. No value returns the property value.
     * @param append {boolean} appends textValue if true, otherwise destructive
     * @returns {ExtendedNodeList|string} ExtendedNodeList instance
     * or (if &lt;code>textValue&lt;/code> is empty) the property value.
     */
    text: (extCollection, textValue, append) => {
      if (extCollection.isEmpty()) {
        return extCollection;
      }

      const cb = el => el.textContent = append ? el.textContent + textValue : textValue;

      if (!textValue) {
        return extCollection.first().textContent;
      }

      return loop(extCollection, cb);
    },
    /**
     * Alias for loop
     * @memberof module:JQL/JQLMethods
     * @example
     * $(`#somediv`).each( (el, i) => ...);
     * // where $ = the alias for the ExtendedNodeList constructor
     * @param cb {function} lambda to execute on each element of the collection
     */
    each: (extCollection, cb) => loop(extCollection, cb),
    /**
     * Remove each collection element from the DOM tree
     * @memberof module:JQL/JQLMethods
     * @param selector {string}
     */
    remove: (extCollection, selector) => {
      const remover = el => el.remove();
      if (selector) {
        const selectedElements = extCollection.find$(selector);
        !selectedElements.isEmpty() &amp;&amp; loop(selectedElements, remover);
        return;
      }
      loop(extCollection, remover);
    },
    /**
     * Get computed style for a css property of the first element of the ExtendedNodeList instance
     * @memberof module:JQL/JQLMethods
     * @param property {string} the css property (e.g. &lt;code>left&lt;/code> or &lt;code>display&lt;/code>)
     * @returns {CSSStyleDeclaration}
     */
    computedStyle: (extCollection, property) => extCollection.first() &amp;&amp; getComputedStyle(extCollection.first())[property],
    /**
     * Get the value of a data-attribute for the first element of the ExtendedNodeList instance
     * @memberof module:JQL/JQLMethods
     * @param dataAttribute {string} some attribute, e.q. 'initial'
     * @param valueWhenFalsy {*} value when the attribute does not exist
     * @returns {string|number|undefined}
     */
    getData: (extCollection, dataAttribute, valueWhenFalsy) => extCollection.first() &amp;&amp;
      extCollection.first().dataset &amp;&amp; extCollection.first().dataset[dataAttribute] || valueWhenFalsy,
    /**
     * Is the collection of the current (implicit) ExtendedNodeList instance empty?
     * @memberof module:JQL/JQLMethods
     * @returns {boolean}
     */
    isEmpty: extCollection => extCollection.collection.length &lt; 1,
    /**
     * Checks the values of pseudo selectors :hidden, :visible or :disabled
     * &lt;br>&lt;b>Todo&lt;/b>: really useful?
     * @memberof module:JQL/JQLMethods
     * @param checkValue {string} one of :visibile, :hidden, :disabled
     * @returns {string|boolean}
     */
    is: (extCollection, checkValue) => {
      const firstElem = extCollection.first();

      if (!firstElem) {
        return true;
      }

      switch (checkValue) {
        case ":visible": {
          return isVisible(firstElem); // TODO
        }
        case ":hidden":
          return !isVisible(firstElem);
        case ":disabled":
          return firstElem.getAttribute("readonly") || firstElem.getAttribute("disabled");
        default:
          return true;
      }
    },
    /**
     * Checks if (one of) [classNames] is assigned to the first
     * element of the ExtendedNodeList instance
     * @memberof module:JQL/JQLMethods
     * @param classNames {...string} one or more classNames
     * @returns {boolean} true if one of classNames exists
     */
    hasClass: (extCollection, ...classNames) => {
      const firstElem = extCollection.first();
      return extCollection.isEmpty() || !firstElem.classList.length
        ? false : classNames.find(cn => firstElem.classList.contains(cn)) || false;
    },
    /**
     * Replace a child in the collection of an ExtendedNodeList instance
     * with something else
     * @memberof module:JQL/JQLMethods
     * @param oldChild {HTMLElement|string} &lt;code>HTMLElement&lt;/code> or selector string
     * @param newChild {HTMLElement} &lt;code>HTMLElement&lt;/code> or
     * &lt;code>ExtendedNodeList&lt;/code> instance
     * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
     */
    replace: (extCollection, oldChild, newChild) => {
      const firstElem = extCollection.first();

      if (newChild.isJQL) {
        newChild = newChild.first();
      }

      if (firstElem &amp;&amp; oldChild) {
        oldChild = oldChild.constructor === String
          ? firstElem.querySelector(oldChild)
          : oldChild.isJQL
            ? oldChild.first()
            : oldChild;

        if (oldChild &amp;&amp; newChild) {
          oldChild.replaceWith(newChild);
        }
      }

      return extCollection;
    },
    /**
     * Replace the collection of an ExtendedNodeList instance with something else
     * @memberof module:JQL/JQLMethods
     * @param newChild {HTMLElement|ExtendedNodeList} &lt;code>HTMLElement&lt;/code> or
     * &lt;code>ExtendedNodeList&lt;/code> instance
     * @returns {ExtendedNodeList} &lt;code>ExtendedNodeList&lt;/code> instance, so chainable
     * &lt;br>&lt;b>Note:&lt;/b> the returned &lt;code>ExtendedNodeList&lt;/code> instance is the replaced element.
     */
    replaceMe: (extCollection, newChild) => {
      newChild = newChild instanceof HTMLElement ? new extCollection.constructor(newChild) : newChild;
      extCollection.parent().replace(extCollection, newChild)
      return newChild;
    },
    /**
     * Get or set the value of (the first element of)
     * the ExtendedNodeList instance, where the first
     * element is one of input or select HTMLElement
     * @memberof module:JQL/JQLMethods
     * @param value2Set {string|ExtendedNodeList} string or ExtendedNodeList
     * @returns {string|undefined}
     */
    val: (extCollection, value2Set) => {
      const firstElem = extCollection.first();

      if (!firstElem || !inputElems.includes(firstElem["constructor"])) {
        return extCollection;
      }

      if (value2Set === undefined) {
        return firstElem.value;
      }

      firstElem.value = `${value2Set}`.length &lt; 1 ? "" : value2Set;

      return extCollection;
    },
    /**
     * Get the direct parent node of the first element of the ExtendedNodeList instance
     * @memberof module:JQL/JQLMethods
     * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
     */
    parent: extCollection => !extCollection.isEmpty() &amp;&amp; extCollection.first().parentNode &amp;&amp;
      new extCollection.constructor(extCollection.first().parentNode) || extCollection,
    /**
     * Appends one ore more elements to each element of the instance collection (for real, in the DOM tree).
     * &lt;br>If elems2Append consists of html string(s), they should contain &lt;i>valid&lt;/i> html
     * (e.g., no flow content in in elements expecting phrasing content, so for example no &lt;code>&amp;lt;h1>&lt;/code>
     * within &lt;code>&amp;lt;p>&lt;/code>)
     * @memberof module:JQL/JQLMethods
     * @param elems2Append {...(string|HTMLElement|Text|Comment|ExtendedNodeList)} The element(s) to append.
     * Types may be mixed.
     * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
     */
    append: (extCollection, ...elems2Append) => {
      if (!extCollection.isEmpty() &amp;&amp; elems2Append) {

        for (let i = 0; i &lt; elems2Append.length; i += 1) {
          const elem2Append = elems2Append[i];

          if (elem2Append.constructor === String) {
            extCollection.collection.forEach(el => el.appendChild(createElementFromHtmlString(elem2Append)))
            return extCollection;
          }

          if (isNode(elem2Append)) {
            extCollection.collection.forEach(el =>
              el.appendChild(elem2Append instanceof Comment ? elem2Append : elem2Append.cloneNode(true)));
            return extCollection;
          }

          if (elem2Append.isJQL &amp;&amp; !elem2Append.isEmpty()) {
            const elems = elem2Append.collection.slice();
            elem2Append.remove();
            elems.forEach(e2a =>
              extCollection.collection.forEach(el =>
                el.appendChild(e2a instanceof Comment ? e2a : e2a.cloneNode(true))));
          }
        }
      }

      return extCollection;
    },
    /**
     * Injects an element at the start of each element of the collection of an instance of ExtendedNodeList.
     * &lt;br>When [elem] is a html string, it should be valid html, otherwise nothing is prepended obviously
     * (e.g., no flow content in in elements expecting phrasing content, so for example no &lt;code>&amp;lt;h1>&lt;/code>
     * within &lt;code>&amp;lt;p>&lt;/code>)
     * @memberof module:JQL/JQLMethods
     * @param elems2Prepend {...(string|HTMLElement|Text|Comment|ExtendedNodeList)} the element(s) to append.
     * The types may be mixed.
     * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
     */
    prepend: (extCollection, ...elems2Prepend) => {
      if (!extCollection.isEmpty() &amp;&amp; elems2Prepend) {

        for (let i = 0; i &lt; elems2Prepend.length; i += 1) {
          const elem2Prepend = elems2Prepend[i];

          if (elem2Prepend.constructor === String) {
            extCollection.collection.forEach(el =>
              el.insertBefore(createElementFromHtmlString(elem2Prepend), el.firstChild))
            return extCollection;
          }

          if (isNode(elem2Prepend)) {
            extCollection.collection.forEach(el =>
              el.insertBefore(
                elem2Prepend instanceof Comment ? elem2Prepend : elem2Prepend.cloneNode(true), el.firstChild));
            return extCollection;
          }

          if (elem2Prepend.isJQL &amp;&amp; !elem2Prepend.isEmpty()) {
            const elems = elem2Prepend.collection.slice();
            elem2Prepend.remove();
            elems.forEach(e2a =>
              extCollection.collection.forEach(el =>
                el &amp;&amp; el.insertBefore(e2a instanceof Comment ? e2a : e2a.cloneNode(true), el.firstChild)));
          }
        }
      }

      return extCollection;
    },
    /**
     * Appends the collection of one ExtendedNodeList instance to another instance,
     * so injects the element(s) of [extCollection] to each element of [extCollection2AppendTo]
     * (for real, injected and visible in the DOM tree).
     * &lt;br>&lt;b>Note&lt;/b>: this returns the extCollection2AppendTo (so, the parent JQL instance).
     * @memberof module:JQL/JQLMethods
     * @param extCollection2AppendTo {ExtendedNodeList} the instance to append to
     * @returns {ExtendedNodeList} i.c. extCollection2AppendTo
     */
    appendTo: (extCollection, extCollection2AppendTo) => {
      if (!extCollection2AppendTo.isJQL) {
        extCollection2AppendTo = _$.virtual(extCollection2AppendTo);
      }
      return extCollection2AppendTo.append(extCollection);
    },
    /**
     * Prepends the collection of one ExtendedNodeList instance to each element of another instance,
     * so injects the element(s) of [extCollection] to each element of [extCollection2AppendTo]
     * (for real, injected and visible in the DOM tree).
     * &lt;br>&lt;b>Note&lt;/b>: this returns the extCollection2AppendTo (so, the parent JQL instance).
     * @memberof module:JQL/JQLMethods
     * @param extCollection2PrependTo {ExtendedNodeList} the instance to append to
     * @returns {ExtendedNodeList} i.c. extCollection2PrependTo
     */
    prependTo: (extCollection, extCollection2PrependTo) => {
      if (!extCollection2PrependTo.isJQL) {
        extCollection2PrependTo = _$.virtual(extCollection2PrependTo);
      }

      return extCollection2PrependTo.prepend(extCollection);
    },
    /**
     * Retrieves a single element from an instance of ExtendedNodeList
     * and returns a new ExtendedNodeList instance from that element
     * @memberof module:JQL/JQLMethods
     * @param indexOrSelector {number|string}the index of the instance collection
     * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
     */
    single: (extCollection, indexOrSelector = "0") => {
      if (extCollection.collection.length > 0) {
        if (isNaN(+indexOrSelector) &amp;&amp; extCollection.find(indexOrSelector)) {
          return extCollection.find$(indexOrSelector);
        }
        const index = +indexOrSelector;
        return index &lt; extCollection.collection.length
          ? _$(extCollection.collection[indexOrSelector])
          : _$(extCollection.collection.slice(-1));
      } else {
        return extCollection;
      }
    },
    /**
     * Retrieve the extCollection instance collection as a Nodelist. It may
     * be a way to duplicate a collection of nodes (see example).
     * &lt;br>&lt;b>Note&lt;/b> the list is &lt;b>&lt;i>not&lt;/b>&lt;/i> a live Node list.
     * In other words: the nodes are copies of the original (and do not
     * exist in the DOM tree).
     * &lt;br>&lt;b>Note&lt;/b> if the nodes contain an id, it is removed (element id's
     * must be unique).
     * &lt;br>[See also (ExtendedNodeList instance).duplicate]{@link module:JQL/JQLMethods~duplicate}
     * @memberof module:JQL/JQLMethods
     * @example
     * import $ from "JQueryLike.js";
     * // create 2 nodes in the DOM tree and retrieve the collection as NodeList
     * const nodes = $([`&lt;div id="some">Hello&lt;/div>`, `&lt;div id="thing">World&lt;/div>`]).toNodeList();
     * // change the text of the nodes in the list
     * for (let node of nodes) {
     *   node.textContent += `!`;
     * }
     * // append the nodes (and colorize)
     * $(nodes).style({color: `red`});
     * // result in DOM (classNames are random)
     * &lt;div id="some">Hello&lt;/div>
     * &lt;div id="thing">World&lt;/div>
     * &lt;div style="color: red;">Hello!&lt;/div>
     * &lt;div style="color: red;">World!&lt;/div>
     * @returns {NodeList}
     */
    toNodeList: extCollection => {
      const virtual = document.createElement(`div`);

      for (let elem of extCollection.collection) {
        const nodeClone = document.importNode(elem, true);
        nodeClone.removeAttribute(`id`);
        virtual.append(nodeClone);
      }

      return virtual.childNodes;
    },
    /**
     * Duplicate an ExtendedNodeList instance (to memory (default) or
     * to DOM. The elements within the instance are cloned (and their id's removed)
     * and the resulting &lt;code>NodeList&lt;/code> is converted to a new instance.
     * &lt;br>&lt;b>Note&lt;/b> check the cloned nodes classList/properties/attributes: you may want
     * to change them before injecting to DOM.
     * @memberof module:JQL/JQLMethods
     * @example
     * import $ from "JQueryLike.js";
     * const someElem = Object.assign(
     *    document.createElement(`div`),
     *    {innerHTML: `hello`, className: `someClass` });
     * $.setStyle(`.someClass`, {color: `brown`});
     * $( [...Array(2)].map(_ => someElem.cloneNode(true) ) )
     *  .append(document.createTextNode(` world!`))
     *  .prepend(document.createTextNode(`We say: `))
     *  .each(el =>
     *    el.setAttribute(`id`, `_${ Math.floor(10000 + Math.random() * 10000).toString(16)}` ))
     *  // elements are injected to DOM. Now continue with a duplicate
     *  .duplicate(true)
     *  .removeClass(`someClass`)
     *  .text(` That's right folks. Bye!`, true);
     *  // output
     *  &lt;div class="someClass" id="_2f03">We say: hello world!&lt;/div>
     *  &lt;div class="someClass" id="_413b">We say: hello world!&lt;/div>
     *  &lt;div class>We say: hello world! That's right folks. Bye!&lt;/div>
     *  &lt;div class>We say: hello world! That's right folks. Bye!&lt;/div>
     * @param toDOM {boolean} true: inject the duplicate to DOM, false (default) to memory
     * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
     */
    duplicate: (extCollection, toDOM = false) => {
      const clonedCollection = extCollection.toNodeList();
      return toDOM ? _$(clonedCollection) : _$.virtual(clonedCollection);
    },
    /**
     * Write an instance of ExtendedNodeList to the DOM ([root] or document.body).
     * &lt;br>&lt;b>Note&lt;/b>: this works only for virtual instances (so, existing in memory) and
     * can be done once for such an instance.
     * @memberof module:JQL/JQLMethods
     * @param root {HTMLElement} the root to which the instance should be appended
     * @param position {insertPositions} the position of the element(s) to inject
     * (default "beforeend")
     * @returns {ExtendedNodeList}
     */
    toDOM: (extCollection, root = document.body, position = insertPositions.BeforeEnd) => {
      if (extCollection.isVirtual) {
        extCollection.isVirtual = false;
        inject2DOMTree(extCollection.collection, root, position);
      }
      return extCollection;
    },
    /**
     * Retrieve the first element of the ExtendedNodeList instance collection
     * @memberof module:JQL/JQLMethods
     * @param asExtCollection {boolean} if true, return new ExtendedNodeList instance, else HTMLElement
     * true => return as new ExtendedNodeList instance, false: as raw HTMLElement
     * @returns {ExtendedNodeList|HTMLElement|undefined} ExtendedNodeList instance, HTMLElement or nothing
     */
    first: (extCollection, asExtCollection = false) => {
      if (extCollection.collection.length > 0) {
        return asExtCollection
          ? extCollection.single()
          : extCollection.collection[0];
      }
      return undefined;
    },
    /**
     * Retrieve first element from the collection of the ExtendedNodeList instance
     * and return that as a new ExtendedNodeList instance
     * (if it exists, otherwise undefined)
     * @memberof module:JQL/JQLMethods
     * @param indexOrSelector {number} the collection index
     * @returns {ExtendedNodeList|undefined} ExtendedNodeList instance or nothing
     */
    first$: (extCollection, indexOrSelector) => extCollection.single(indexOrSelector),
    /**
     * Find one or more elements within the ExtendedNodeList instance collection
     * using a css query (e.g. '.someClass')
     * @memberof module:JQL/JQLMethods
     * @param selector {string} css selector
     * @returns {Array|NodeListOf}
     */
    find: (extCollection, selector) => extCollection.first()?.querySelectorAll(selector) || [],
    /**
     * Find one or more elements within the ExtendedNodeList instance collection
     * using a css query (e.g. '.someClass') and return a new ExtendedNodeList instance
     * from it's result
     * @memberof module:JQL/JQLMethods
     * @param selector {string} css selector
     * @returns {ExtendedNodeList|undefined} a new ExtendedNodeList instance or nothing
     */
    find$: (extCollection, selector) => {
      const found = extCollection.collection.reduce((acc, el) =>
        [...acc, [...el.querySelectorAll(selector)]], [])
        .flat()
        .filter(el => el &amp;&amp; el instanceof HTMLElement);
      return found.length &amp;&amp; _$.virtual(found);
    },
    /**
     * Get a property/attribute value of first element from
     * the ExtendedNodeList instance collection or set it for each element of
     * the collection
     * TODO: only existing properties, which is quite secure, but may be annonying
     * &lt;br>maybe this should be done via DOMCleanup (weed out forbidden properties)
     * @memberof module:JQL/JQLMethods
     * @param property {string} (e.g. 'title')
     * @param value {string|undefined} If it has a value, then set the property value
     * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
     */
    prop: (extCollection, property, value) => {
      if (!value) {
        return !extCollection.isEmpty() ? extCollection.first()[property] : undefined;
      }

      if (!extCollection.isEmpty()) {
        loop(extCollection, el => el[property] = value);
      }

      return extCollection;
    },
    /**
     * Add handler lambda for an ExtendedNodeList instance.
     * &lt;br>A handler id is created if applicable (addHandlerId)
     * @memberof module:JQL/JQLMethods
     * @param type {string} event type (e.g. 'click')
     * @param callback {function} handler lambda
     * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
     */
    on: (extCollection, type, callback) => {
      if (extCollection.collection.length) {
        const cssSelector = addHandlerId(extCollection);
        handlerFactory(extCollection, type, cssSelector, callback);
      }

      return extCollection;
    },

    /**
     * Get (inner-) html of the first element in the
     * collection of [extCollection] or set html for each
     * element of the collection.
     * Overwrites current html of the elements, or appends the value to it.
     * Note: the html is always sanitized (see [module HtmlCleanup]{@link: module:JQL/XHelpers/HtmlCleanup})
     * @memberof module:JQL/JQLMethods
     * @param htmlValue {ExtendedNodeList|string|undefined} JQL instance, html string or nothing
     * @param append {boolean} appends the html if true, otherwise destructive
     * @returns {string|ExtendedNodeList} current ExtendedNodeList instance or
     * (if &lt;code>htmlValue&lt;/code> is empty) the current (inner)html of the first
     * element.
     */
    html: (extCollection, htmlValue, append) => {
      if (htmlValue === undefined) {
        return extCollection.first()?.innerHTML;
      }

      if (!extCollection.isEmpty()) {
        const nwElement = htmlValue.isJQL
          ? htmlValue.first() : createElementFromHtmlString(`&lt;div>${htmlValue}&lt;/div>`);

        if (!(nwElement instanceof Comment)) {
          const cb = el => el.innerHTML = append ? el.innerHTML + nwElement.innerHTML : nwElement.innerHTML;
          return loop(extCollection, cb);
        }
      }

      return extCollection;
    },
    /**
     * Retrieves outer html for the first element of the ExtendedNodeList instance
     * @memberof module:JQL/JQLMethods
     * @returns {string|undefined}
     */
    outerHtml: extCollection => (extCollection.first() || {outerHTML: undefined}).outerHTML,
    /**
     * Sets/adds/removes html for an element within the collection
     * of the ExtendedNodeList instance (identified with a css query).
     * @memberof module:JQL/JQLMethods
     * @param forQuery {string} a css query (e.g. `#someId`)
     * @param htmlString {string} the html string to replace or append to exististing.
     * &lt;br>&lt;b>Note&lt;/b>: if the string is empty, the html is removed
     * &lt;br>&lt;b>Note&lt;/b>: the html is always sanitized (see DOMCleanup)
     * @param append {boolean} if true html will be appended, otherwise destructive
     * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
     */
    htmlFor: (extCollection, forQuery, htmlString = "", append = false) => {
      if (forQuery &amp;&amp; extCollection.collection.length) {
        const el2Change = extCollection.find$(forQuery);
        if (!el2Change) {
          return extCollection;
        }

        if (`{htmlValue}`.trim().length &lt; 1) {
          el2Change.textContent = "";
          return extCollection;
        }

        const nwElement = createElementFromHtmlString(`&lt;div>${htmlString}&lt;/div>`);
        nwElement &amp;&amp; el2Change.html(nwElement.innerHTML, append);
      }
      return extCollection;
    },
    /**
     * retrieve the current dimensions of the first element in the collection
     * @memberof module:JQL/JQLMethods
     * @returns {DOMRect | undefined}
     */
    dimensions: extCollection => extCollection.first()?.getBoundingClientRect(),
    /**
     * Create event handler lambda(s)
     * &lt;br>&lt;b>Note&lt;/b>: may be empty
     * @memberof module:JQL/JQLMethods
     * @param type {string} event type (e.g. 'click')
     * @param cssSelector {string} e.g. '#someId'
     * @param callbacks {...function} one or more lambda functions
     * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
     */
    delegate: (extCollection, type, cssSelector, ...callbacks) => {
      callbacks.forEach(callback => handlerFactory(extCollection, type, cssSelector, callback));
      return extCollection;
    },
    /**
     * Add one or multiple handler lambda(s) for event [type] and
     * the ExtendedNodeList instance
     * @memberof module:JQL/JQLMethods
     * @param type {string} event type (e.g. 'click')
     * @param callbacks {...Function} one or more lambda functions
     * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
     */
    ON: (extCollection, type, ...callbacks) => {
      if (extCollection.collection.length) {
        callbacks.forEach(cb => extCollection.on(type, cb));
      }

      return extCollection;
    },
  },
};
export default allMethods;</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Thu Jul 14 2022 18:17:19 GMT+0200 (Midden-Europese zomertijd) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
