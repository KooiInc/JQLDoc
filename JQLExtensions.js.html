<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JQLExtensions.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Attributes.html">Attributes</a></li><li><a href="module-DOM.html">DOM</a><ul class='methods'><li data-type='method'><a href="module-DOM.html#~createElementFromHtmlString">createElementFromHtmlString</a></li><li data-type='method'><a href="module-DOM.html#~element2DOM">element2DOM</a></li></ul></li><li><a href="module-HandlerFactory.html">HandlerFactory</a><ul class='methods'><li data-type='method'><a href="module-HandlerFactory.html#~addListenerIfNotExisting">addListenerIfNotExisting</a></li><li data-type='method'><a href="module-HandlerFactory.html#~createHandlerForHID">createHandlerForHID</a></li><li data-type='method'><a href="module-HandlerFactory.html#~metaHandler">metaHandler</a></li></ul></li><li><a href="module-Helpers.html">Helpers</a><ul class='methods'><li data-type='method'><a href="module-Helpers.html#~createRegExp">createRegExp</a></li><li data-type='method'><a href="module-Helpers.html#~frequencies">frequencies</a></li><li data-type='method'><a href="module-Helpers.html#~groupDigits">groupDigits</a></li><li data-type='method'><a href="module-Helpers.html#~hasDuplicatesForKeys">hasDuplicatesForKeys</a></li><li data-type='method'><a href="module-Helpers.html#~isEven">isEven</a></li><li data-type='method'><a href="module-Helpers.html#~isObjectAndNotArray">isObjectAndNotArray</a></li><li data-type='method'><a href="module-Helpers.html#~repeat">repeat</a></li><li data-type='method'><a href="module-Helpers.html#~time">time</a></li><li data-type='method'><a href="module-Helpers.html#~time2Fragments">time2Fragments</a></li><li data-type='method'><a href="module-Helpers.html#~toDashedNotation">toDashedNotation</a></li><li data-type='method'><a href="module-Helpers.html#~toUndashedNotation">toUndashedNotation</a></li><li data-type='method'><a href="module-Helpers.html#~truncateHtmlStr">truncateHtmlStr</a></li></ul></li><li><a href="module-HtmlCleanup.html">HtmlCleanup</a><ul class='methods'><li data-type='method'><a href="module-HtmlCleanup.html#~logElementCreationErrors">logElementCreationErrors</a></li><li data-type='method'><a href="module-HtmlCleanup.html#~setTagPermission">setTagPermission</a></li></ul></li><li><a href="module-HtmlTags.html">HtmlTags</a><ul class='methods'><li data-type='method'><a href="module-HtmlTags.html#.isAllowed">isAllowed</a></li><li data-type='method'><a href="module-HtmlTags.html#~setTagPermission">setTagPermission</a></li></ul></li><li><a href="module-JQL.html">JQL</a><ul class='methods'><li data-type='method'><a href="module-JQL.html#~ExtendedNodeList">ExtendedNodeList</a></li><li data-type='method'><a href="module-JQL.html#~node">node</a></li><li data-type='method'><a href="module-JQL.html#~nodes">nodes</a></li><li data-type='method'><a href="module-JQL.html#~popup">popup</a></li><li data-type='method'><a href="module-JQL.html#~setStyle">setStyle</a></li><li data-type='method'><a href="module-JQL.html#~setSystemLogActiveState">setSystemLogActiveState</a></li><li data-type='method'><a href="module-JQL.html#~text">text</a></li><li data-type='method'><a href="module-JQL.html#~virtual">virtual</a></li></ul></li><li><a href="module-JQLCollectionExtensions.html">JQLCollectionExtensions</a><ul class='methods'><li data-type='method'><a href="module-JQLCollectionExtensions.html#~addClass">addClass</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~assignAttrValues">assignAttrValues</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~attr">attr</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~clear">clear</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~css">css</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~empty">empty</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~hide">hide</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~remove">remove</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~removeAttr">removeAttr</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~removeClass">removeClass</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~replaceClass">replaceClass</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~setData">setData</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~show">show</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~style">style</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~toggleAttr">toggleAttr</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~toggleClass">toggleClass</a></li><li data-type='method'><a href="module-JQLCollectionExtensions.html#~toggleStyleFragments">toggleStyleFragments</a></li></ul></li><li><a href="module-JQLExtensionHelpers.html">JQLExtensionHelpers</a><ul class='methods'><li data-type='method'><a href="module-JQLExtensionHelpers.html#~getAllDataAttributeValues">getAllDataAttributeValues</a></li><li data-type='method'><a href="module-JQLExtensionHelpers.html#~hex2Full">hex2Full</a></li><li data-type='method'><a href="module-JQLExtensionHelpers.html#~hex2RGBA">hex2RGBA</a></li><li data-type='method'><a href="module-JQLExtensionHelpers.html#~initializePrototype">initializePrototype</a></li><li data-type='method'><a href="module-JQLExtensionHelpers.html#~isVisible">isVisible</a></li><li data-type='method'><a href="module-JQLExtensionHelpers.html#~loop">loop</a></li></ul></li><li><a href="module-JQLExtensions.html">JQLExtensions</a><ul class='methods'><li data-type='method'><a href="module-JQLExtensions.html#~append">append</a></li><li data-type='method'><a href="module-JQLExtensions.html#~appendTo">appendTo</a></li><li data-type='method'><a href="module-JQLExtensions.html#~computedStyle">computedStyle</a></li><li data-type='method'><a href="module-JQLExtensions.html#~delegate">delegate</a></li><li data-type='method'><a href="module-JQLExtensions.html#~dimensions">dimensions</a></li><li data-type='method'><a href="module-JQLExtensions.html#~duplicate">duplicate</a></li><li data-type='method'><a href="module-JQLExtensions.html#~each">each</a></li><li data-type='method'><a href="module-JQLExtensions.html#~find">find</a></li><li data-type='method'><a href="module-JQLExtensions.html#~find$">find$</a></li><li data-type='method'><a href="module-JQLExtensions.html#~first">first</a></li><li data-type='method'><a href="module-JQLExtensions.html#~first$">first$</a></li><li data-type='method'><a href="module-JQLExtensions.html#~getData">getData</a></li><li data-type='method'><a href="module-JQLExtensions.html#~hasClass">hasClass</a></li><li data-type='method'><a href="module-JQLExtensions.html#~html">html</a></li><li data-type='method'><a href="module-JQLExtensions.html#~htmlFor">htmlFor</a></li><li data-type='method'><a href="module-JQLExtensions.html#~is">is</a></li><li data-type='method'><a href="module-JQLExtensions.html#~isEmpty">isEmpty</a></li><li data-type='method'><a href="module-JQLExtensions.html#~on">on</a></li><li data-type='method'><a href="module-JQLExtensions.html#~ON">ON</a></li><li data-type='method'><a href="module-JQLExtensions.html#~outerHtml">outerHtml</a></li><li data-type='method'><a href="module-JQLExtensions.html#~parent">parent</a></li><li data-type='method'><a href="module-JQLExtensions.html#~prepend">prepend</a></li><li data-type='method'><a href="module-JQLExtensions.html#~prependTo">prependTo</a></li><li data-type='method'><a href="module-JQLExtensions.html#~prop">prop</a></li><li data-type='method'><a href="module-JQLExtensions.html#~remove">remove</a></li><li data-type='method'><a href="module-JQLExtensions.html#~replace">replace</a></li><li data-type='method'><a href="module-JQLExtensions.html#~replaceMe">replaceMe</a></li><li data-type='method'><a href="module-JQLExtensions.html#~single">single</a></li><li data-type='method'><a href="module-JQLExtensions.html#~text">text</a></li><li data-type='method'><a href="module-JQLExtensions.html#~toDOM">toDOM</a></li><li data-type='method'><a href="module-JQLExtensions.html#~toNodeList">toNodeList</a></li><li data-type='method'><a href="module-JQLExtensions.html#~val">val</a></li></ul></li><li><a href="module-JQLLog.html">JQLLog</a><ul class='methods'><li data-type='method'><a href="module-JQLLog.html#.debugLog%255Breversed%255D">debugLog[reversed]</a></li><li data-type='method'><a href="module-JQLLog.html#.debugLog%255BtoConsole%255D">debugLog[toConsole]</a></li><li data-type='method'><a href="module-JQLLog.html#~Log">Log</a></li><li data-type='method'><a href="module-JQLLog.html#~setStyling4Log">setStyling4Log</a></li></ul></li><li><a href="module-Popup.html">Popup</a><ul class='methods'><li data-type='method'><a href="module-Popup.html#~popupFactory">popupFactory</a></li><li data-type='method'><a href="module-Popup.html#~popupFactory_create">popupFactory_create</a></li><li data-type='method'><a href="module-Popup.html#~popupFactory_createTimed">popupFactory_createTimed</a></li><li data-type='method'><a href="module-Popup.html#~popupFactory_remove">popupFactory_remove</a></li><li data-type='method'><a href="module-Popup.html#~popupFactory_removeModal">popupFactory_removeModal</a></li></ul></li><li><a href="module-Styling.html">Styling</a><ul class='methods'><li data-type='method'><a href="module-Styling.html#~changeCssStyleRule">changeCssStyleRule</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">JQLExtensions.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//noinspection JSUnresolvedFunction,JSUnresolvedVariable,DuplicatedCode,JSValidateJSDoc,JSClosureCompilerSyntax,JSCheckFunctionSignatures

//#region ExtendedNodeList lambda's
import {createElementFromHtmlString, element2DOM, insertPositions} from "./DOM.js";
import {loop, addHandlerId, isVisible, isNode} from "./JQLExtensionHelpers.js";
import handlerFactory from "./HandlerFactory.js";
import {randomStringExtension} from "./Helpers.js";
import _$ from "./JQueryLike.js";
randomStringExtension();

/**
 * All extension methods for &lt;code>ExtendedNodeList&lt;/code> where looping may not be
 * an option. The methods end up in the JQL prototype
 * [See JQLExtensionHelpers]{@link module:JQLExtensionHelpers~initializePrototype}
 * &lt;p>&lt;b>Notes&lt;/b>&lt;/p>
 *  &lt;ul>&lt;li>Most methods are &lt;i>chainable&lt;/i>.
 *  &lt;li>&lt;code>[...].css&lt;/code>&lt;/a> is a collection method, not in this file but also chainable, see
 *  [the documentation there]{@link module:JQLCollectionExtensions}&lt;/a>.
 *  &lt;li>&lt;code>(implicit)&lt;/code> means the parameter should not be provided in the caller&lt;/ul>
 * @module
 * @example
 * import $ from "JQueryLike.js";
 * // chainability means:
 * $(`&lt;div id="helloworld">`)
 *  .text(`Example: hello ... world`)
 *  .append($(`&lt;span> OK&lt;/span>`))
 *  .css({
 *    marginTop: `0.5rem`,
 *    border: `3px solid green`,
 *    padding: `5px`,
 *    fontSize: `1.2em`,
 *    display: `inline-block`, })
 *  .find$(`span`)
 *  .css({className: `okRed`, color: `red`});
 *  // result (class names are partly random):
 *  // &lt;div id="helloworld" class="JQLCreated_YZ5XnwbCEGxH">Example: hello ... world&lt;span class="okRed"> OK&lt;/span>&lt;/div>
 */

/**
 * The JQLLike library.&lt;br>
 * See [module JQL]{@link module:JQL~ExtendedNodeList}
 * @private
 * @typedef {function(...[*]): ExtendedNodeList} ExtendedNodeList
 */

/**
 * Get textContent of the first element in the
 * the collection of [extCollection] or set the textContent
 * for each element of the collection. .
 * overwrites current textContent of the first element,
 * or appends the text to it.
 * &lt;br>&lt;b>Note&lt;/b>: uses textContent, so no html here
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param textValue {string|undefined} the text to inject. No value returns the property value.
 * @param append {boolean} appends textValue if true, otherwise destructive
 * @returns {ExtendedNodeList|string} ExtendedNodeList instance
 * or (if &lt;code>textValue&lt;/code> is empty) the property value.
 */
const text = (extCollection, textValue, append) => {
  if (extCollection.isEmpty()) {
    return extCollection;
  }

  const cb = el => el.textContent = append ? el.textContent + textValue : textValue;

  if (!textValue) {
    return extCollection.first().textContent;
  }

  return loop(extCollection, cb);
};

/**
 * Alias for loop
 * @example
 * $(`#somediv`).each( (el, i) => ...);
 * // where $ = the alias for the ExtendedNodeList constructor
 */
const each = (extCollection, lambda) => loop(extCollection, lambda);

/**
 * Remove each collection element from the DOM tree
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 */
const remove = (extCollection, selector) => {
  const remover = el => el.remove();
  if (selector) {
    const selectedElements = extCollection.find$(selector);
    !selectedElements.isEmpty() &amp;&amp; loop(selectedElements, remover);
    return;
  }
  loop(extCollection, remover);
}

/**
 * Get computed style for a css property of the first element of the ExtendedNodeList instance
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param property the css property (e.g. &lt;code>left&lt;/code> or &lt;code>display&lt;/code>)
 * @returns {string | undefined}
 */
const computedStyle = (extCollection, property) => {
  if (extCollection.first()) {
    return getComputedStyle(extCollection.first())[property];
  }
}


/**
 * Get the value of a data-attribute for the first element of the ExtendedNodeList instance
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param dataAttribute {string} some attribute, e.q. 'initial'
 * @param valueWhenFalsy {string|number|undefined} value when the attribute does not exist
 * @returns {string|number|undefined}
 */
const getData = (extCollection, dataAttribute, valueWhenFalsy) => {
  return extCollection.first()?.dataset[dataAttribute] || valueWhenFalsy;
};

/**
 * Is the collection of the current (implicit) ExtendedNodeList instance empty?
 * @param extCollection {ExtendedNodeList} current ExtendedNodeList
 * @returns {boolean}
 */
const isEmpty = extCollection => extCollection.collection.length &lt; 1;

/**
 * Checks the values of pseudo selectors :hidden, :visible or :disabled
 * &lt;br>&lt;b>Todo&lt;/b>: really useful?
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param checkValue {string} one of :visibile, :hidden, :disabled
 * @returns {string|boolean}
 */
const is = (extCollection, checkValue) => {
  const firstElem = extCollection.first();

  if (!firstElem) {
    return true;
  }

  switch (checkValue) {
    case ":visible": {
      return isVisible(firstElem); // TODO
    }
    case ":hidden":
      return !isVisible(firstElem);
    case ":disabled":
      return firstElem.getAttribute("readonly") || firstElem.getAttribute("disabled");
    default:
      return true;
  }
};

/**
 * Checks if (one of) [classNames] exist in one of the elements of the
 * ExtendedNodeList instance element collection
 * @param extCollection {ExtendedNodeList} (implicit) current ExentedNodeList instance
 * @param classNames {...string} one or more classNames
 * @returns {boolean} true if one of classNames exists
 */
const hasClass = (extCollection, ...classNames) => {
  return !extCollection.isEmpty() &amp;&amp;
    extCollection.collection?.filter(el =>
      classNames?.find(cn => el.classList.contains(cn))).length > 0;
};

/**
 * Replace a child in the collection of an ExtendedNodeList instance
 * with something else
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param oldChild {HTMLElement|string} &lt;code>HTMLElement&lt;/code> or selector string
 * @param newChild {HTMLElement} &lt;code>HTMLElement&lt;/code> or
 * &lt;code>ExtendedNodeList&lt;/code> instance
 * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
 */
const replace = (extCollection, oldChild, newChild) => {
  const firstElem = extCollection.first();

  if (newChild.isJQL) {
    newChild = newChild.first();
  }

  if (firstElem &amp;&amp; oldChild) {
    oldChild = oldChild.constructor === String
      ? firstElem.querySelector(oldChild)
      : oldChild.isJQL
        ? oldChild.first()
        : oldChild;

    if (oldChild &amp;&amp; newChild) {
      oldChild.replaceWith(newChild);
    }
  }

  return extCollection;
};

/**
 * Replace the collection of an ExtendedNodeList instance with something else
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param newChild {HTMLElement|ExtendedNodeList} &lt;code>HTMLElement&lt;/code> or
 * &lt;code>ExtendedNodeList&lt;/code> instance
 * @returns {ExtendedNodeList} &lt;code>ExtendedNodeList&lt;/code> instance, so chainable
 * &lt;br>&lt;b>Note:&lt;/b> the returned &lt;code>ExtendedNodeList&lt;/code> instance is the replaced element.
 */
const replaceMe = (extCollection, newChild) => {
  newChild = newChild instanceof HTMLElement ? new extCollection.constructor(newChild) : newChild;
  extCollection.parent().replace(extCollection, newChild)
  return newChild;
};

/**
 * Get or set the value of (the first element of)
 * the ExtendedNodeList instance, where the first
 * element is one of input or select HTMLElement
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param value2Set {string|undefined} string or nothing
 * @returns {string|undefined}
 */
const val = (extCollection, value2Set) => {
  const firstElem = extCollection.first();

  if (!firstElem) { return; }

  if ([HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement].includes(firstElem?.constructor)) {
    if (value2Set || [String, Number].find(v2s => value2Set.constructor === v2s)) {
      firstElem.value = value2Set;
    }

    return firstElem.value;
  }
};

/**
 * Get the direct parent node of the first element of the ExtendedNodeList instance
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
 */
const parent = extCollection => !extCollection.isEmpty() &amp;&amp; extCollection.first().parentNode &amp;&amp;
  new extCollection.constructor(extCollection.first().parentNode) || extCollection;

/**
 * Appends one ore more elements to each element of the instance collection (for real, in the DOM tree).
 * &lt;br>If elems2Append consists of html string(s), they should contain &lt;i>valid&lt;/i> html
 * (e.g., no flow content in in elements expecting phrasing content, so for example no &lt;code>&amp;lt;h1>&lt;/code>
 * within &lt;code>&amp;lt;p>&lt;/code>)
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param elems2Append {...(string|HTMLElement|Text|Comment|ExtendedNodeList)} The element(s) to append.
 * Types may be mixed.
 * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
 */
const append = (extCollection, ...elems2Append) => {
  if (!extCollection.isEmpty() &amp;&amp; elems2Append) {

    for (let i = 0; i &lt; elems2Append.length; i += 1) {
      const elem2Append = elems2Append[i];

      if (elem2Append.constructor === String) {
        extCollection.collection.forEach(el => el.appendChild(createElementFromHtmlString(elem2Append)))
        return extCollection;
      }

      if (isNode(elem2Append)) {
        extCollection.collection.forEach(el =>
          el.appendChild(elem2Append instanceof Comment ? elem2Append : elem2Append.cloneNode(true)));
        return extCollection;
      }

      if (elem2Append.isJQL &amp;&amp; !elem2Append.isEmpty()) {
        const elems = elem2Append.collection.slice();
        elem2Append.remove();
        elems.forEach( e2a =>
          extCollection.collection.forEach(el =>
            el.appendChild(e2a instanceof Comment ? e2a : e2a.cloneNode(true))) );
      }
    }
  }

  return extCollection;
};

/**
 * Injects an element at the start of each element of the collection of an instance of ExtendedNodeList.
 * &lt;br>When [elem] is a html string, it should be valid html, otherwise nothing is prepended obviously
 * (e.g., no flow content in in elements expecting phrasing content, so for example no &lt;code>&amp;lt;h1>&lt;/code>
 * within &lt;code>&amp;lt;p>&lt;/code>)
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param elems2Prepend {...(string|HTMLElement|Text|Comment|ExtendedNodeList)} the element(s) to append.
 * The types may be mixed.
 * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
 */
const prepend = (extCollection, ...elems2Prepend) => {
  if (!extCollection.isEmpty() &amp;&amp; elems2Prepend) {

    for (let i = 0; i &lt; elems2Prepend.length; i += 1) {
      const elem2Prepend = elems2Prepend[i];

      if (elem2Prepend.constructor === String) {
        extCollection.collection.forEach(el =>
          el.insertBefore(createElementFromHtmlString(elem2Prepend), el.firstChild))
        return extCollection;
      }

      if (isNode(elem2Prepend)) {
        extCollection.collection.forEach(el =>
          el.insertBefore(
            elem2Prepend instanceof Comment ? elem2Prepend : elem2Prepend.cloneNode(true), el.firstChild));
        return extCollection;
      }

      if (elem2Prepend.isJQL &amp;&amp; !elem2Prepend.isEmpty()) {
        const elems = elem2Prepend.collection.slice();
        elem2Prepend.remove();
        elems.forEach( e2a =>
          extCollection.collection.forEach(el =>
            el &amp;&amp; el.insertBefore(e2a instanceof Comment ? e2a : e2a.cloneNode(true), el.firstChild) ) );
      }
    }
  }

  return extCollection;
};

/**
 * Appends the collection of one ExtendedNodeList instance to another instance,
 * so injects the element(s) of [extCollection] to each element of [extCollection2AppendTo]
 * (for real, injected and visible in the DOM tree).
 * &lt;br>&lt;b>Note&lt;/b>: this returns the extCollection2AppendTo (so, the parent JQL instance).
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param extCollection2AppendTo {ExtendedNodeList} the instance to append to
 * @returns {ExtendedNodeList} i.c. extCollection2AppendTo
 */
const appendTo = (extCollection, extCollection2AppendTo) => {
  if (!extCollection2AppendTo.isJQL) {
    extCollection2AppendTo = _$.virtual(extCollection2AppendTo);
  }
  return extCollection2AppendTo.append(extCollection);
};

/**
 * Prepends the collection of one ExtendedNodeList instance to each element of another instance,
 * so injects the element(s) of [extCollection] to each element of [extCollection2AppendTo]
 * (for real, injected and visible in the DOM tree).
 * &lt;br>&lt;b>Note&lt;/b>: this returns the extCollection2AppendTo (so, the parent JQL instance).
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param extCollection2PrependTo {ExtendedNodeList} the instance to append to
 * @returns {ExtendedNodeList} i.c. extCollection2PrependTo
 */
const prependTo = (extCollection, extCollection2PrependTo) => {
  if (!extCollection2PrependTo.isJQL) {
    extCollection2PrependTo = _$.virtual(extCollection2PrependTo);
  }

  return extCollection2PrependTo.prepend(extCollection);
};

/**
 * Retrieves a single element from an instance of ExtendedNodeList
 * and returns a new ExtendedNodeList instance from that element
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param indexOrSelector {number|string}the index of the instance collection
 * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
 */
const single = (extCollection, indexOrSelector = "0") => {
  if (extCollection.collection.length > 0) {
    if (isNaN(+indexOrSelector) &amp;&amp; extCollection.find(indexOrSelector)) {
      return extCollection.find$(indexOrSelector);
    }
    const index = +indexOrSelector;
    return index &lt; extCollection.collection.length
      ? new extCollection.constructor(extCollection.collection[indexOrSelector])
      : extCollection;
  } else {
    return extCollection;
  }
};

/**
 * Retrieve the extCollection instance collection as a Nodelist. It may
 * be a way to duplicate a collection of nodes (see example).
 * &lt;br>&lt;b>Note&lt;/b> the list is &lt;b>&lt;i>not&lt;/b>&lt;/i> a live Node list.
 * In other words: the nodes are copies of the original (and do not
 * exist in the DOM tree).
 * &lt;br>&lt;b>Note&lt;/b> if the nodes contain an id, it is removed (element id's
 * must be unique).
 * &lt;br>[See also (ExtendedNodeList instance).duplicate]{@link module:JQLExtensions~duplicate}
 * @example
 * import $ from "JQueryLike.js";
 * // create 2 nodes in the DOM tree and retrieve the collection as NodeList
 * const nodes = $([`&lt;div id="some">Hello&lt;/div>`, `&lt;div id="thing">World&lt;/div>`]).toNodeList();
 * // change the text of the nodes in the list
 * for (let node of nodes) {
 *   node.textContent += `!`;
 * }
 * // append the nodes (and colorize)
 * $(nodes).style({color: `red`});
 * // result in DOM (classNames are random)
 * &lt;div id="some">Hello&lt;/div>
 * &lt;div id="thing">World&lt;/div>
 * &lt;div style="color: red;">Hello!&lt;/div>
 * &lt;div style="color: red;">World!&lt;/div>
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @returns {NodeList}
 */
const toNodeList = extCollection => {
  const virtual = document.createElement(`div`);

  for (let elem of extCollection.collection) {
    const nodeClone = document.importNode(elem, true);
    nodeClone.removeAttribute(`id`);
    virtual.append(nodeClone);
  }

  return virtual.childNodes;
};

/**
 * Duplicate an ExtendedNodeList instance (to memory (default) or
 * to DOM. The elements within the instance are cloned (and their id's removed)
 * and the resulting &lt;code>NodeList&lt;/code> is converted to a new instance.
 * &lt;br>&lt;b>Note&lt;/b> check the cloned nodes classList/properties/attributes: you may want
 * to change them before injecting to DOM.
 * @example
 * import $ from "JQueryLike.js";
 * const someElem = Object.assign(
 *    document.createElement(`div`),
 *    {innerHTML: `hello`, className: `someClass` });
 * $.setStyle(`.someClass`, {color: `brown`});
 * $( [...Array(2)].map(_ => someElem.cloneNode(true) ) )
 *  .append(document.createTextNode(` world!`))
 *  .prepend(document.createTextNode(`We say: `))
 *  .each(el =>
 *    el.setAttribute(`id`, `_${ Math.floor(10000 + Math.random() * 10000).toString(16)}` ))
 *  // elements are injected to DOM. Now continue with a duplicate
 *  .duplicate(true)
 *  .removeClass(`someClass`)
 *  .text(` That's right folks. Bye!`, true);
 *  // output
 *  &lt;div class="someClass" id="_2f03">We say: hello world!&lt;/div>
 *  &lt;div class="someClass" id="_413b">We say: hello world!&lt;/div>
 *  &lt;div class>We say: hello world! That's right folks. Bye!&lt;/div>
 *  &lt;div class>We say: hello world! That's right folks. Bye!&lt;/div>
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param toDOM {boolean} true: inject the duplicate to DOM, false (default) to memory
 * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
 */
const duplicate = (extCollection, toDOM = false) => {
  const clonedCollection = extCollection.toNodeList();
  return toDOM ? _$(clonedCollection) : _$.virtual(clonedCollection);
}

/**
 * Write an instance of ExtendedNodeList to the DOM ([root] or document.body).
 * &lt;br>&lt;b>Note&lt;/b>: this works only for virtual instances (so, existing in memory) and
 * can be done once for such an instance.
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param root {HTMLElement} the root to which the instance should be appended
 * @returns {ExtendedNodeList}
 */
const toDOM = (extCollection, root = document.body) => {
  if (extCollection.isVirtual) {
    extCollection.isVirtual = false;
    return _$(extCollection.collection, root);
  }
  return extCollection;
};

/**
 * Retrieve the first element of the ExtendedNodeList instance collection
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param asExtCollection {boolean} if true, return new ExtendedNodeList instance, else HTMLElement
 * true => return as new ExtendedNodeList instance, false: as raw HTMLElement
 * @returns {ExtendedNodeList|HTMLElement|undefined} ExtendedNodeList instance, HTMLElement or nothing
 */
const first = (extCollection, asExtCollection = false) => {
  if (extCollection.collection.length > 0) {
    return asExtCollection
      ? extCollection.single()
      : extCollection.collection[0];
  }
  return undefined;
};

/**
 * Retrieve first [el] from the collection of the ExtendedNodeList instance
 * and return it as a new ExtendedNodeList instance
 * (if it exists, otherwise undefined)
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param indexOrSelector {number} the collection index
 * @returns {ExtendedNodeList|undefined} ExtendedNodeList instance or nothing
 */
const first$ = (extCollection, indexOrSelector) => extCollection.single(indexOrSelector);

/**
 * Find one or more elements within the ExtendedNodeList instance collection
 * using a css query (e.g. '.someClass')
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param selector {string} css selector
 * @returns {Array|NodeListOf}
 */
const find = (extCollection, selector) =>
  extCollection.first()?.querySelectorAll(selector) || [];

/**
 * Find one or more elements within the ExtendedNodeList instance collection
 * using a css query (e.g. '.someClass') and return a new ExtendedNodeList instance
 * from it's result
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param selector {string} css selector
 * @returns {ExtendedNodeList|undefined} a new ExtendedNodeList instance or nothing
 */
const find$ = (extCollection, selector) => {
  const found = extCollection.collection.reduce( (acc, el) =>
    [ ...acc, [...el.querySelectorAll(selector)] ], [])
    .flat()
    .filter( el => el &amp;&amp; el instanceof HTMLElement);
  return found.length &amp;&amp; _$.virtual(found);
};

/**
 * Get a property/attribute value of first element from
 * the ExtendedNodeList instance collection or set it for each element of
 * the collection
 * TODO: only existing properties, which is quite secure, but may be annonying
 * &lt;br>maybe this should be done via DOMCleanup (weed out forbidden properties)
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param property {string} (e.g. 'title')
 * @param value {string|undefined} If it has a value, then set the property value
 * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
 */
const prop = (extCollection, property, value) => {
  if (value === undefined) {
    return !extCollection.isEmpty ? extCollection.first()[property] : undefined;
  }

  if (!extCollection.isEmpty) {
    loop(extCollection, el => el[property] = value);
  }

  return extCollection;
};

/**
 * Add handler lambda for an ExtendedNodeList instance.
 * &lt;br>A handler id is created if applicable (addHandlerId)
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param type {string} event type (e.g. 'click')
 * @param callback {function} handler lambda
 * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
 */
const on = (extCollection, type, callback) => {
  if (extCollection.collection.length) {
    const cssSelector = addHandlerId(extCollection);
    handlerFactory(extCollection, type, cssSelector, callback);
  }

  return extCollection;
};

/**
 * Get (inner-) html of the first element in the
 * collection of [extCollection] or set html for each
 * element of the collection.
 * Overwrites current html of the elements, or appends the value to it.
 * Note: the html is always sanitized (see [module HtmlCleanup]{@link: module:HtmlCleanup})
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param htmlValue {ExtendedNodeList|string|undefined} JQL instance, html string or nothing
 * @param append {boolean} appends the html if true, otherwise destructive
 * @returns {string|ExtendedNodeList} current ExtendedNodeList instance or
 * (if &lt;code>htmlValue&lt;/code> is empty) the current (inner)html of the first
 * element.
 */
const html = (extCollection, htmlValue, append) => {
  if (htmlValue === undefined) {
    return extCollection.first()?.innerHTML;
  }

  if (!extCollection.isEmpty()) {
    const nwElement = htmlValue.isJQL
      ? htmlValue.first() : createElementFromHtmlString(`&lt;div>${htmlValue}&lt;/div>`);

    if (!(nwElement instanceof Comment)) {
      const cb = el => el.innerHTML = append ? el.innerHTML + nwElement.innerHTML : nwElement.innerHTML;
      return loop(extCollection, cb);
    }
  }

  return extCollection;
};

/**
 * Retrieves outer html for the first element of the ExtendedNodeList instance
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @returns {string|undefined}
 */
const outerHtml = extCollection => (extCollection.first() || {outerHTML: undefined}).outerHTML;

/**
 * Sets/adds/removes html for an element within the collection
 * of the ExtendedNodeList instance (identified with a css query).
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param forQuery {string} a css query (e.g. `#someId`)
 * @param htmlString {string} the html string to replace or append to exististing.
 * &lt;br>&lt;b>Note&lt;/b>: if the string is empty, the html is removed
 * &lt;br>&lt;b>Note&lt;/b>: the html is always sanitized (see DOMCleanup)
 * @param append {boolean} if true html will be appended, otherwise destructive
 * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
 */
const htmlFor = (extCollection, forQuery, htmlString = "", append = false) => {
  if (forQuery &amp;&amp; extCollection.collection.length) {
    const el2Change = extCollection.find$(forQuery);
    if (!el2Change) {
      return extCollection;
    }

    if (`{htmlValue}`.trim().length &lt; 1) {
      el2Change.textContent = "";
      return extCollection;
    }

    const nwElement = createElementFromHtmlString(`&lt;div>${htmlString}&lt;/div>`);
    nwElement &amp;&amp; el2Change.html(nwElement.innerHTML, append);
  }
  return extCollection;
};

/**
 * retrieve the current dimensions of the first element in the collection
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @returns {DOMRect | undefined}
 */
const dimensions = extCollection => extCollection.first()?.getBoundingClientRect();

/**
 * Create event handler lambda(s)
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * &lt;br>&lt;b>Note&lt;/b>: may be empty
 * @param type {string} event type (e.g. 'click')
 * @param cssSelector {string} e.g. '#someId'
 * @param callbacks {...function} one or more lambda functions
 * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
 */
const delegate = (extCollection, type, cssSelector, ...callbacks) => {
  callbacks.forEach(callback =>
    handlerFactory(extCollection, type, cssSelector, callback));

  return extCollection;
};

/**
 * Add one or multiple handler lambda(s) for event [type] and
 * the ExtendedNodeList instance
 * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
 * @param type {string} event type (e.g. 'click')
 * @param callbacks {...functions} one or more lambda functions
 * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
 */
const ON = (extCollection, type, ...callbacks) => {
  if (extCollection.collection.length) {
    callbacks.forEach(cb => extCollection.on(type, cb));
  }

  return extCollection;
};

export default {
    text, remove, each, getData, isEmpty, is, hasClass, replace, replaceMe, val,
    parent, append, appendTo, prepend, prependTo, single, first, first$, find, find$,
    computedStyle, dimensions, prop, on, html, outerHtml, htmlFor,
    delegate, ON, toNodeList, duplicate, toDOM,
};

//#endregion ExtendedNodeList lambda's</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Nov 29 2021 18:38:44 GMT+0100 (Midden-Europese standaardtijd) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
